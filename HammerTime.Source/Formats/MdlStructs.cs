using System.IO;
using System.Numerics;
using System.Runtime.InteropServices;

namespace Sledge.Formats.Model.Source
{
	public enum StudioHdrFlags : int
	{
		// This flag is set if no hitbox information was specified
		STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX = 0x00000001,

		//NOTE,:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
		// = models ,when we change materials.
		STUDIOHDR_FLAGS_USES_ENV_CUBEMAP = 0x00000002,

		//Use ,this when there are translucent parts to the model but we're not going to sort it 
		STUDIOHDR_FLAGS_FORCE_OPAQUE = 0x00000004,

		//Use ,this when we want to render the opaque parts during the opaque pass
		// = and ,the translucent parts during the translucent pass
		STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS = 0x00000008,

		//This ,is set any time the .qc files has $staticprop in it
		// = Means ,there's no bones and no transforms
		STUDIOHDR_FLAGS_STATIC_PROP = 0x00000010,

		//NOTE,:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
		// = models ,when we change materials.
		STUDIOHDR_FLAGS_USES_FB_TEXTURE = 0x00000020,

		//This ,flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
		//  = for ,the .mdl (the shadow lod is the last entry in the lod list if present)
		STUDIOHDR_FLAGS_HASSHADOWLOD = 0x00000040,

		//NOTE,:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
		// = models ,when we change materials.
		STUDIOHDR_FLAGS_USES_BUMPMAPPING = 0x00000080,

		//NOTE,:  This flag is set when we should use the actual materials on the shadow LOD
		// = instead ,of overriding them with the default one (necessary for translucent shadows)
		STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS = 0x00000100,

		//NOTE,:  This flag is set when we should use the actual materials on the shadow LOD
		// = instead ,of overriding them with the default one (necessary for translucent shadows)
		STUDIOHDR_FLAGS_OBSOLETE = 0x00000200,

		STUDIOHDR_FLAGS_UNUSED = 0x00000400,

		//NOTE,:  This flag is set at mdl build time
		STUDIOHDR_FLAGS_NO_FORCED_FADE = 0x00000800,

		//NOTE,:  The npc will lengthen the viseme check to always include two phonemes
		STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE = 0x00001000,

		//This ,flag is set when the .qc has $constantdirectionallight in it
		// = If ,set, we use constantdirectionallightdot to calculate light intensity
		// = rather ,than the normal directional dot product
		// = only ,valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
		STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x00002000,

		//Flag ,to mark delta flexes as already converted from disk format to memory format
		STUDIOHDR_FLAGS_FLEXES_CONVERTED = 0x00004000,

		//Indicates ,the studiomdl was built in preview mode
		STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE = 0x00008000,

		//Ambient ,boost (runtime flag)
		STUDIOHDR_FLAGS_AMBIENT_BOOST = 0x00010000,

		//Don,'t cast shadows from this model (useful on first-person models)
		STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS = 0x00020000,

		// alpha ,textures should cast shadows in vrad on this model (ONLY prop_static!)
		STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS = 0x00040000,


		// ,= flagged ,on load to indicate no animation events on this model
		STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE = 0x00200000,
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct Studiohdr
	{
		public int id;             // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
		public int version;        // Format version number, such as 48 (0x30,0x00,0x00,0x00)
		public int checksum;       // This has to be the same in the phy and vtx files to load!
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
		public char[] name;       // The internal name of the model, padding with null bytes.
								  // Typically "my_model.mdl" will have an internal name of "my_model"
		public int dataLength;     // Data size of MDL file in bytes.

		// A vector is 12 bytes, three 4-byte float-values in a row.
		public Vector3 eyeposition;    // Position of player viewpoint relative to model origin
		public Vector3 illumposition;  // Position (relative to model origin) used to calculate ambient light contribution and cubemap reflections for the entire model.
		public Vector3 hull_min;       // Corner of model hull box with the least X/Y/Z values
		public Vector3 hull_max;       // Opposite corner of model hull box
		public Vector3 view_bbmin;     // Same, but for bounding box,
		public Vector3 view_bbmax;     // which is used for view culling

		public StudioHdrFlags flags;          // Binary flags in little-endian order. 
											  // ex (0x010000C0) means flags for position 0, 30, and 31 are set. 
											  // Set model flags section for more information

		/*
		 * After this point, the header contains many references to offsets
		 * within the MDL file and the number of items at those offsets.
		 *
		 * Offsets are from the very beginning of the file.
		 * 
		 * Note that indexes/counts are not always paired and ordered consistently.
		 */

		// mstudiobone_t
		public int bone_count;    // Number of data sections (of type mstudiobone_t)
		public int bone_offset;   // Offset of first data section

		// mstudiobonecontroller_t
		public int bonecontroller_count;
		public int bonecontroller_offset;

		// mstudiohitboxset_t
		public int hitbox_count;
		public int hitbox_offset;

		// mstudioanimdesc_t
		public int localanim_count;
		public int localanim_offset;

		// mstudioseqdesc_t
		public int localseq_count;
		public int localseq_offset;

		public int activitylistversion; // ??
		public int eventsindexed;       // ??

		// VMT texture filenames
		// mstudiotexture_t
		public int texture_count;
		public int texture_offset;

		// This offset points to a series of ints.
		// Each int value, in turn, is an offset relative to the start of this header/the-file,
		// At which there is a null-terminated string.
		public int texturedir_count;
		public int texturedir_offset;

		// Each skin-family assigns a texture-id to a skin location
		public int skinreference_count;
		public int skinrfamily_count;
		public int skinreference_index;

		// mstudiobodyparts_t
		public int bodypart_count;
		public int bodypart_offset;

		// Local attachment points        
		// mstudioattachment_t
		public int attachment_count;
		public int attachment_offset;

		// Node values appear to be single bytes, while their names are null-terminated strings.
		public int localnode_count;
		public int localnode_index;
		public int localnode_name_index;

		// mstudioflexdesc_t
		public int flexdesc_count;
		public int flexdesc_index;

		// mstudioflexcontroller_t
		public int flexcontroller_count;
		public int flexcontroller_index;

		// mstudioflexrule_t
		public int flexrules_count;
		public int flexrules_index;

		// IK probably referse to inverse kinematics
		// mstudioikchain_t
		public int ikchain_count;
		public int ikchain_index;

		// Information about any "mouth" on the model for speech animation
		// More than one sounds pretty creepy.
		// mstudiomouth_t
		public int mouths_count;
		public int mouths_index;

		// mstudioposeparamdesc_t
		public int localposeparam_count;
		public int localposeparam_index;

		/*
		 * For anyone trying to follow along, as of this writing,
		 * the next "surfaceprop_index" value is at position 0x0134 (308)
		 * from the start of the file.
		 */

		// Surface property value (single null-terminated string)
		public int surfaceprop_index;

		// Unusual: In this one index comes first, then count.
		// Key-value data is a series of strings. If you can't find
		// what you're interested in, check the associated PHY file as well.
		public int keyvalue_index;
		public int keyvalue_count;

		// More inverse-kinematics
		// mstudioiklock_t
		public int iklock_count;
		public int iklock_index;


		public float mass;      // Mass of object (4-bytes) in kilograms

		public int contents;    // contents flag, as defined in bspflags.h
								// not all content types are valid; see 
								// documentation on $contents QC command

		// Other models can be referenced for re-used sequences and animations
		// (See also: The $includemodel QC option.)
		// mstudiomodelgroup_t
		public int includemodel_count;
		public int includemodel_index;

		public int virtualModel;    // Placeholder for mutable-void*
									// Note that the SDK only compiles as 32-bit, so an int and a pointer are the same size (4 bytes)

		// mstudioanimblock_t
		public int animblocks_name_index;
		public int animblocks_count;
		public int animblocks_index;

		public int animblockModel; // Placeholder for mutable-void*

		// Points to a series of bytes?
		public int bonetablename_index;

		public int vertex_base;    // Placeholder for void*
		public int offset_base;    // Placeholder for void*

		// Used with $constantdirectionallight from the QC 
		// Model should have flag #13 set if enabled
		public byte directionaldotproduct;

		public byte rootLod;    // Preferred rather than clamped

		// 0 means any allowed, N means Lod 0 -> (N-1)
		public byte numAllowedRootLods;

		public byte unused0; // ??
		public int unused1; // ??

		// mstudioflexcontrollerui_t
		public int flexcontrollerui_count;
		public int flexcontrollerui_index;

		public float vertAnimFixedPointScale; // ??
		public int unused2;

		/**
		 * Offset for additional header information.
		 * May be zero if not present, or also 408 if it immediately 
		 * follows this studiohdr_t
		 */
		// studiohdr2_t
		public int studiohdr2index;

		public int unused3; // ??

		/**
		 * As of this writing, the header is 408 bytes long in total
		 */
	};
	public class StudioSequenceDescription
	{
		public StudioSequenceDesc Data { get; set; }
		public string Label { get; set; }
		public string ActivityName { get; set; }
		internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
		{
			Data = Marshal.PtrToStructure<StudioSequenceDesc>(handle.AddrOfPinnedObject() + offset);
			br.BaseStream.Seek(offset + Data.szlabelindex, SeekOrigin.Begin);
			Label = br.ReadNullTerminatedString();
			br.BaseStream.Seek(offset + Data.szactivitynameindex, SeekOrigin.Begin);
			ActivityName = br.ReadNullTerminatedString();
		}

	}
	public struct StudioSequenceDesc
	{
		public int baseptr;
		//inline studiohdr_t	*pStudiohdr( void ) const { return (studiohdr_t *)(((byte *)this) + baseptr); }

		public int szlabelindex;

		public int szactivitynameindex;

		public int flags;      // looping/non-looping flags

		public int activity;   // initialized at loadtime to game DLL values
		public int actweight;

		public int numevents;
		public int eventindex;
		//inline mstudioevent_t *pEvent( int i ) const { Assert( i >= 0 && i < numevents); return (mstudioevent_t *)(((byte *)this) + eventindex) + i; };

		public Vector3 bbmin;      // per sequence bounding box
		public Vector3 bbmax;

		public int numblends;

		// Index into array of shorts which is groupsize[0] x groupsize[1] in length
		public int animindexindex;

		//inline int			anim( int x, int y ) const
		//{
		//	if ( x >= groupsize[0] )
		//	{
		//		x = groupsize[0] - 1;
		//	}

		//	if ( y >= groupsize[1] )
		//	{
		//		y = groupsize[ 1 ] - 1;
		//	}

		//	int offset = y * groupsize[0] + x;
		//	short *blends = (short *)(((byte *)this) + animindexindex);
		//	int value = (int)blends[ offset ];
		//	return value;
		//}

		public int movementindex;  // [blend] float array for blended movement
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public int[] groupsize;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]

		public int[] paramindex;  // X, Y, Z, XR, YR, ZR
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]

		public float[] paramstart;    // local (0..1) starting value
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]

		public float[] paramend;   // local (0..1) ending value
		public int paramparent;

		public float fadeintime;       // ideal cross fate in time (0.2 default)
		public float fadeouttime;  // ideal cross fade out time (0.2 default)

		public int localentrynode;     // transition node at entry
		public int localexitnode;      // transition node at exit
		public int nodeflags;      // transition rules

		public float entryphase;       // used to match entry gait
		public float exitphase;        // used to match exit gait

		public float lastframe;        // frame that should generation EndOfSequence

		public int nextseq;        // auto advancing sequences
		public int pose;           // index of delta animation between end and nextseq

		public int numikrules;

		public int numautolayers;  //
		public int autolayerindex;
		//inline mstudioautolayer_t *pAutolayer( int i ) const { Assert( i >= 0 && i < numautolayers); return (mstudioautolayer_t *)(((byte *)this) + autolayerindex) + i; };

		public int weightlistindex;
		//inline float		*pBoneweight( int i ) const { return ((float *)(((byte *)this) + weightlistindex) + i); };
		//inline float		weight( int i ) const { return *(pBoneweight( i)); };

		// FIXME: make this 2D instead of 2x1D arrays
		public int posekeyindex;
		//float				*pPoseKey( int iParam, int iAnim ) const { return (float *)(((byte *)this) + posekeyindex) + iParam * groupsize[0] + iAnim; }
		//float				poseKey( int iParam, int iAnim ) const { return *(pPoseKey( iParam, iAnim )); }

		public int numiklocks;
		public int iklockindex;
		//inline mstudioiklock_t *pIKLock( int i ) const { Assert( i >= 0 && i < numiklocks); return (mstudioiklock_t *)(((byte *)this) + iklockindex) + i; };

		// Key values
		public int keyvalueindex;
		public int keyvaluesize;
		//inline const char * KeyValueText( void ) const { return keyvaluesize != 0 ? ((char *)this) + keyvalueindex : NULL; }

		public int cycleposeindex;     // index of pose parameter to use as cycle index

		public int activitymodifierindex;
		public int numactivitymodifiers;
		//inline mstudioactivitymodifier_t *pActivityModifier( int i ) const { Assert( i >= 0 && i < numactivitymodifiers); return activitymodifierindex != 0 ? (mstudioactivitymodifier_t *)(((byte *)this) + activitymodifierindex) + i : NULL; };
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
		int[] unused;       // remove/add as appropriate (grow back to 8 ints on version change!)

	};
	public class Bone
	{
		public StudioHdrBone Data { get; set; }
		public string BoneName { get; set; }
		internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
		{
			Data = Marshal.PtrToStructure<StudioHdrBone>(handle.AddrOfPinnedObject() + offset);
			br.BaseStream.Seek(offset + Data.bone_name_offset, SeekOrigin.Begin);
			BoneName = br.ReadNullTerminatedString();
		}
	}
	public struct StudioHdrBone
	{
		public uint bone_name_offset;
		public int parent;     // parent bone
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
		public int[] bonecontroller;  // bone controller index, -1 == none
									  // default values
		public Vector3 pos;
		public Quaternion quat;
		public Vector3 rot;
		// compression scale
		public Vector3 posscale;
		public Vector3 rotscale;
		public Matrix3x4 poseToBone;
		public Vector4 qAlignment;
		public int flags;
		public int proctype;
		public int procindex;      // procedural rule
		public int physicsbone;    // index into physically simulated bone

		public int surfacepropidx; // index into string tablefor property name

		public int contents;       // See BSPFlags.h for the contents flags
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public int[] unused;      // remove as appropriate
	}
	public class HitboxSet
	{
		public StudioHdrHitboxSet Header { get; set; }
		public string Name { get; set; }
		public Hitbox[] Hitboxes { get; set; }

		internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
		{
			Header = Marshal.PtrToStructure<StudioHdrHitboxSet>(handle.AddrOfPinnedObject() + offset);
			br.BaseStream.Seek(offset + Header.sznameindex, SeekOrigin.Begin);
			Name = br.ReadNullTerminatedString();
			Hitboxes = new Hitbox[Header.numhitboxes];
			for (int i = 0; i < Header.numhitboxes; i++)
			{
				Hitboxes[i] = new Hitbox();
				var hitboxOffset = offset + Header.hitboxindex + i * Marshal.SizeOf<StudioHdrHitbox>();
				Hitboxes[i].ReadObjects(handle, br, hitboxOffset);
			}
		}
		public class Hitbox
		{
			public StudioHdrHitbox Data { get; set; }
			public string Name { get; set; }
			internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
			{
				Data = Marshal.PtrToStructure<StudioHdrHitbox>(handle.AddrOfPinnedObject() + offset);
				br.BaseStream.Seek(Data.szhitboxnameindex, SeekOrigin.Begin);
				Name = br.ReadNullTerminatedString();
			}
		}

	}

	public struct StudioHdrHitbox
	{
		public int bone;
		public int group;              // intersection group
		public Vector3 bbmin;              // bounding box
		public Vector3 bbmax;
		public int szhitboxnameindex;  // offset to the name of the hitbox.
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public int[] unused;

	};
	public struct StudioHdrHitboxSet
	{
		public int sznameindex;
		public int numhitboxes;
		public int hitboxindex;
	};

	public class AnimDescription
	{
		public StudioHdrAnimDesc Data { get; set; }
		public StudioMovement[] Movement { get; set; }
		public StudioAnimSection[] Frames { get; set; }
		public string Name { get; set; }
		internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
		{
			Data = Marshal.PtrToStructure<StudioHdrAnimDesc>(handle.AddrOfPinnedObject() + offset);
			br.BaseStream.Seek(offset + Data.sznameindex, SeekOrigin.Begin);
			Movement = new StudioMovement[Data.nummovements];
			Frames = new StudioAnimSection[Data.sectionframes];
			for (int i = 0; i < Data.nummovements; i++)
			{
				Movement[i] = Marshal.PtrToStructure<StudioMovement>(handle.AddrOfPinnedObject() + offset + Data.movementindex);
			}
			for (int i = 0; i < Data.sectionframes; i++)
			{
				Frames[i] = Marshal.PtrToStructure<StudioAnimSection>(handle.AddrOfPinnedObject() + offset + Data.sectionindex);
			}
			Name = br.ReadNullTerminatedString();
		}
	}
	public struct StudioHdrAnimDesc
	{
		public uint baseptr;
		public int sznameindex;
		public float fps;      // frames per second	
		public int flags;      // looping/non-looping flags
		public int numframes;

		// piecewise movement
		public int nummovements;
		public int movementindex;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
		public int[] unused1;         // remove as appropriate (and zero if loading older versions)	
		public int animblock;
		public int animindex;   // non-zero when anim data isn't in sections
		public int numikrules;
		public int ikruleindex;    // non-zero when IK data is stored in the mdl
		public int animblockikruleindex; // non-zero when IK data is stored in animblock file
		public int numlocalhierarchy;
		public int localhierarchyindex;
		public int sectionindex;
		public int sectionframes; // number of frames used in each fast lookup section, zero if not used
		public short zeroframespan;    // frames per span
		public short zeroframecount; // number of spans
		public int zeroframeindex;
		public float zeroframestalltime;       // saved during read stalls
	};
	public struct StudioAnimSection
	{
		public int animblock;
		public int animindex;
	};

	public struct StudioMovement
	{
		public int endframe;
		public int motionflags;
		public float v0;           // velocity at start of block
		public float v1;           // velocity at end of block
		public float angle;        // YAW rotation at end of this blocks movement
		public Vector3 vector;      // movement vector relative to this blocks initial angle
		public Vector3 position;    // relative to start of animation???
	};

	public struct Matrix3x4
	{
		public float m11;
		public float m12;
		public float m13;
		public float m21;
		public float m22;
		public float m23;
		public float m31;
		public float m32;
		public float m33;
		public float m41;
		public float m42;
		public float m43;
	}

	public struct StudioMeshData
	{
		// indirection to this mesh's model's vertex data
		//#ifndef PLATFORM_64BITS
		public int modelVertexDataIndex;
		//	const mstudio_modelvertexdata_t	*modelvertexdata;
		//#else
		//	int unused_modelvertexdata;
		//#endif

		// used for fixup calcs when culling top level lods
		// expected number of mesh verts at desired lod
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public int[] numLODVertexes;

		//#ifdef PLATFORM_64BITS
		//	serializedstudioptr_t< const mstudio_modelvertexdata_t >	modelvertexdata;
		//#endif
	};
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct StudioFlex
	{
		public int flexdesc;   // input value
		public float target0;  // zero
		public float target1;  // one
		public float target2;  // one
		public float target3;  // zero
		public int numverts;
		public int vertindex;
		public int flexpair;   // second flex desc
		public char vertanimtype; // See StudioVertAnimType_t
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		char[] unusedchar;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
		int[] unused;
	};

	public struct StudioMesh
	{
		public int material;
		public int modelindex;
		public int numvertices;        // number of unique vertices/normals/texcoords
		public int vertexoffset;       // vertex mstudiovertex_t
		public int numflexes;          // vertex animation
		public int flexindex;

		// special codes for material operations
		public int materialtype;
		public int materialparam;

		// a unique ordinal for this mesh
		public int meshid;
		public Vector3 center;
		public StudioMeshData vertexdata;

		//#ifdef PLATFORM_64BITS
		//	int					unused[6]; // remove as appropriate
		//#else
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		int[] unused; // remove as appropriate
					   //#endif

	};
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct StudioEyeball
	{
		public int sznameindex;
		public int bone;
		public Vector3 org;
		public float zoffset;
		public float radius;
		public Vector3 up;
		public Vector3 forward;
		public int texture;
		public int unused1;
		public float iris_scale;
		public int unused2;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public int[] upperflexdesc;   // index of raiser, neutral, and lowerer flexdesc that is set by flex controllers
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public int[] lowerflexdesc;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public float[] uppertarget;       // angle (radians) of raised, neutral, and lowered lid positions
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public float lowertarget;
		public int[] upperlidflexdesc;   // index of flex desc that actual lid flexes look to
		public int lowerlidflexdesc;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public int[] unused;          // These were used before, so not guaranteed to be 0
		public bool m_bNonFACS;            // Never used before version 44
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
		public char[] unused3;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]
		public int[] unused4;
	};
	public struct mstudio_modelvertexdata_t
	{

		// base of external vertex data stores
		int pVertexData;
		int pTangentData;
	};
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct StudioModel
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
		public char[] name;
		public int type;
		public float boundingradius;
		public int nummeshes;
		public int meshindex;

	// cache purposes
		public int numvertices;        // number of unique vertices/normals/texcoords
		public int vertexindex;        // vertex Vector
		public int tangentsindex;      // tangents Vector
		public int numattachments;
		public int attachmentindex;
		public int numeyeballs;
		public int eyeballindex;

		public mstudio_modelvertexdata_t vertexdata;

		//#ifdef PLATFORM_64BITS
		//	int					unused[6];		// mstudio_modelvertexdata_t has 2 naked ptrs
		//#else
		//int unused[8];      // remove as appropriate
							//#endif
	};

	public struct StudioBodypart
	{
		public int sznameindex;
		public int nummodels;
		public int baseIndex;
		public int modelindex; // index into models array
	};

	public class Bodypart
	{
		public StudioBodypart Header { get; set; }
		public string Name { get; set; }
		public StudioModel[] Models { get; set; }
		internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
		{
			Header = Marshal.PtrToStructure<StudioBodypart>(handle.AddrOfPinnedObject() + offset);
			br.BaseStream.Seek(offset + Header.sznameindex, SeekOrigin.Begin);
			Name = br.ReadNullTerminatedString();
			Models = new StudioModel[Header.nummodels];
			for (int i = 0; i < Header.nummodels; i++)
			{
				Models[i] = new StudioModel();
				var modelOffset = offset + Header.modelindex + i * Marshal.SizeOf<Source.StudioModel>();
				Models[i].ReadObjects(handle, br, modelOffset);
			}
		}

		public class StudioModel
		{
			public Source.StudioModel Data { get; set; }
			public string Name { get; set; }
			public StudioMesh[] Meshes { get; set; }
			public StudioEyeball[] Eyeballs { get; set; }
			internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
			{
				Data = Marshal.PtrToStructure<Sledge.Formats.Model.Source.StudioModel>(handle.AddrOfPinnedObject() + offset);
				Name = new string(Data.name).TrimEnd('\0');
				Meshes = new StudioMesh[Data.nummeshes];
				for (int i = 0; i < Data.nummeshes; i++)
				{
					Meshes[i] = new StudioMesh();
					var meshOffset = offset + Data.meshindex + i * Marshal.SizeOf<Source.StudioMesh>();
					Meshes[i].ReadObjects(handle, br, meshOffset);
				}
				Eyeballs = new StudioEyeball[Data.numeyeballs];
				for (int i = 0; i < Data.numeyeballs; i++)
				{
					Eyeballs[i] = new StudioEyeball();
					var eyeballOffset = offset + Data.eyeballindex + i * Marshal.SizeOf<Source.StudioEyeball>();
					Eyeballs[i].ReadObjects(handle, br, eyeballOffset);
				}
			}
			public class StudioMesh
			{
				public Source.StudioMesh Data { get; set; }
				public string MaterialName { get; set; }
				public StudioFlex[] Flexes { get; set; }
				public StudioMeshData VertexData { get; set; }
				internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
				{
					Data = Marshal.PtrToStructure<Sledge.Formats.Model.Source.StudioMesh>(handle.AddrOfPinnedObject() + offset);
					br.BaseStream.Seek(offset + Data.material, SeekOrigin.Begin);
					MaterialName = br.ReadNullTerminatedString();
					Flexes = new StudioFlex[Data.numflexes];
					for (int i = 0; i < Data.numflexes; i++)
					{
						Flexes[i] = new StudioFlex();
						var flexOffset = offset + Data.flexindex + i * Marshal.SizeOf<Source.StudioFlex>();
						Flexes[i].ReadObjects(handle, br, flexOffset);
					}
					VertexData = new StudioMeshData();
					var vertexDataOffset = offset + Marshal.SizeOf<Sledge.Formats.Model.Source.StudioMesh>();
					VertexData.ReadObjects(handle, br, vertexDataOffset);
				}
				public class StudioFlex
				{
					public Source.StudioFlex Data { get; set; }
					internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
					{
						Data = Marshal.PtrToStructure<Sledge.Formats.Model.Source.StudioFlex>(handle.AddrOfPinnedObject() + offset);
					}
				}
				public class StudioMeshData
				{
					public Source.StudioMeshData Data { get; set; }
					internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
					{
						Data = Marshal.PtrToStructure<Sledge.Formats.Model.Source.StudioMeshData>(handle.AddrOfPinnedObject() + offset);
					}
				}
			}
			public class StudioEyeball
			{
				public Source.StudioEyeball Data { get; set; }
				public string Name { get; set; }
				internal void ReadObjects(GCHandle handle, BinaryReader br, int offset)
				{
					Data = Marshal.PtrToStructure<Sledge.Formats.Model.Source.StudioEyeball>(handle.AddrOfPinnedObject() + offset);
					br.BaseStream.Seek(offset + Data.sznameindex, SeekOrigin.Begin);
					Name = br.ReadNullTerminatedString();
				}
			}
		}
	}
}
